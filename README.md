Бесконечный цикл, т.к. мы выходим только когда нашли узел
к которому можем "подвесить" новый узел, и тогда мы выходим
по return
Мы нашли нужный узел, подвешиваем
Спускаемся "направо"
Мы нашли нужный узел
Спускаемся "налево"
Спускаемся вниз по дереву поиска
Нашли узел с нужным значением
Выбираем куда идти дальше
Фиктивный узел (без значения)
Игнорируем такое же значение
Это фиктивный узел => мы не нашли значения
Нашли нужное значение
Тернарный оператор
(УСЛОВИЕ) ? ЗНАЧЕНИЕ_ЕСЛИ_TRUE : ЗНАЧЕНИЕ_ЕСЛИ_FALSE
Работает так же, как:
if (value == null)
result = 0;
else
result = 1;
TODO: join + split
здесь будут операции...
Интерфейс =  Класс с реализацией этого интерфейса
Добавить новое значение
Добавляем узел с большим значением
Генератор случайных чисел
Проверочный set
Интерфейс =  Класс с реализацией этого интерфейса
Добавить новое значение
Добавляем узел с большим значением
Оптимизация: final List<T> l = new ArrayList<T>(array.length);
Интерфейс =  Класс с реализацией этого интерфейса
Метод add() добавить в конец списка
size() - количество элементов в списке
get(index) - получить элемент с заданным индексом
Добавить элемент в заданнную позицию (элементы с большими индексами сдвигаются вправо)
Теперь 3 элемента: {7, 11, 10}
Преобразование в массив
Добавляем сразу массив элементов
remove(Object o) - удаление элемента по значению
contains(Object o) - наличия элемента в списке
Проверка, содержит ли один список другой список
set(int index, E element)
Список с индекса по индекс [fromIndex, toIndex)
1, 1, 2..
Получаем итератор
Удаляем элемент
i.remove(); // java.lang.UnsupportedOperationException
Метод add() добавить в множество
size() - количество элементов в списке
get(index) - получить элемент с заданным индексом
Добавляем сразу массив элементов
remove(Object o) - удаление элемента по значению
contains(Object o) - наличия элемента в списке
Проверка, содержит ли один список другой список
Получаем итератор
Удаляем элемент
i.remove(); // java.lang.UnsupportedOperationException
